# Lazy
```java
public interface Lazy<T> {

    T get();
}
```
    
* При первом вызове метода <i>Lazy.get</i>, результат получается из вызова <i>Supplier.get()</i>

* Повторные вызовы <i>Lazy.get</i> должны возвращать тот же объект, который вернулся в п.1

* В однопоточном режиме вычисление должно запускаться не более одного раза

* Если работают несколько потоков, возможность повторного запуска вычисления определяется реализацией

---

# LazyFactory

Необходимо создать класс <i>LazyFactory</i>, возвращающий в трех разных методах разные реализации <i>Lazy</i>.

* Для однопоточного режима

* Для многопоточного режима; вычисление не должно производиться > 1 раза (см. Singleton)

* Для многопоточного lock-free режима; вычисление может производиться > 1 раза, но при этом <i>Lazy.get</i> всегда должен возвращать один и тот же объект (см. AtomicReference/AtomicReferenceFieldUpdater)

Рекомендуемый шаблон сигнатуры методов:
```java
public static <T> Lazy<T> createLazy(Supplier<T> supplier) {}
```

---

# Требования:

* Maven/Gradle проект
* Ограничение по памяти на каждый <i>Lazy</i>-объект: не больше двух ссылок
* Тесты
    * однопоточные
    * многопоточные

# Примечания:

* Помните, что <i>Supplier.get</i> может вернуть <i>null</i>.

Срок: <b>15.02.2016 23:59</b>

---

# Формат сдачи

* Каждое задание выполняете в отдельной ветке в репозитории на GitHub
* Создаете pull request ветки в master этого же репозитория
* Тема PR: Java02. ДЗ 01, &lt;фамилия&gt; &lt;имя&gt;
* В комментарии упоминаете username преподавателя (@sproshev)
* Посылаете письмо преподавателю с такой же темой с ссылкой на pull request